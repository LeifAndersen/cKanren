#lang racket

(require "attributes.rkt" "constraints.rkt" "goals.rkt" "package.rkt" 
         "mk-structs.rkt" "ocs.rkt" "constraint-interactions.rkt" 
         "variables.rkt" "errors.rkt" "infs.rkt" "helpers.rkt" "operators.rkt")
(require racket/generator)
(require (for-syntax syntax/parse racket/syntax))

(require optimization-coach)

(provide (all-defined-out))
(provide (for-syntax search-strategy))

;; for subsumption checks
(define (replace-s s^)
  (lambdam@/private (a : s c q t)
    (make-a (substitution s^) c q t)))

;; adds oc to the constraint store if it contains a non-ground var
(define (update-c oc)
  (cond
   [(any/var? (oc-rands oc))
    (update-c-nocheck oc)]
   [else identitym]))

(define (update-c-nocheck oc)
  (run-constraint-interactions oc))

(define (run-constraint-interactions oc)
  (let ([fns (constraint-interactions)])
    (let ci-loop ([fns fns])
      (cond
       [(null? fns) 
        (lambdam@/private (a : s c q t)
          (let ([old-c (constraint-store-c c)])
            (let ([new-store (constraint-store (ext-c oc old-c))])
              (make-a s new-store q t))))]
       [else
        (define fn (cdar fns))
        (define constraint (fn oc))
        (conda [(fn oc)] [(ci-loop (cdr fns))])]))))

;; replaces all ocs with a rator equal to key with ocs^
(define (replace-ocs key ocs^)
  (lambdam@/private (a : s c q t)
    (let* ([old-store (constraint-store-c c)]
           [new-c (hash-update old-store key (lambda (ocs) ocs^) '())]
           [new-store (constraint-store new-c)])
      (make-a s new-store q t))))

(define (run-c-prefix c c^)
  (for/fold 
   ([fn identitym])
   ([(key ocs^) c^])
   (define ocs (hash-ref c key '()))
   (let prefix-loop ([ocs^ ocs^])
     (cond
      [(eq? ocs ocs^) fn]
      [else
       (conj 
        (prefix-loop (cdr ocs^))
        (oc-proc (car ocs^)))]))))

;; DFS: first do the continuation that was already in the store, then
;; do the continuation generated by running that goal, then finally do
;; the input continuation
(define (update-q-dfs new-enforce)
  (lambdam@/private (a : s c q-old t)
    (let ([q-new
           (lambdam@/private (a : s c q-new t)
             ((ext-q q-new new-enforce)
              (make-a s c empty-q t)))])
      (make-a s c (ext-q q-old q-new) t))))

;; this interweaves DFS and BFS somehow
(define (update-q-hybrid new-enforce)
  (lambdam@/private (a : s c q-old t)
    (let ([q-new
           (lambdam@/private (a : s c q-new t)
             ((ext-q new-enforce q-new)
              (make-a s c empty-q t)))])
      (make-a s c (ext-q q-old q-new) t))))

;; BFS: first do the continuation that was already in the store,
;; leaving the continuation it generates in the store while the input
;; continuation runs.
(define (update-q-bfs new-enforce)
  (lambdam@/private (a : s c q-old t)
    (make-a s c (ext-q q-old new-enforce) t)))

;; should update the substitution with the bindings in s^, then run
;; all the constraints in c^, then run all the constraints relating to
;; the variables in s^
(define (update-package s^/c^)
  (lambdam@/private (a : s c q t)
    (define-values (s^ update-s-fn)
      (update-s-prefix (substitution-s s) (constraint-store-c c) (car s^/c^)))
    (define update-c-fn
      (lambdam@/private (a)
        ((run-c-prefix (constraint-store-c c) (cdr s^/c^))
         (make-a (substitution s^) c q t))))
    (bindm a (conj update-c-fn update-s-fn))))

;; s and c should be unwrapped
(define (update-s-internal x v s c q t)
  (let ([e (add-association-event x v)]
        [x* (if (var? v) `(,x ,v) `(,x))])
    (bindm
      (make-a (substitution (ext-s x v s)) (constraint-store c) q t)
      (run-relevant-constraints x* c e))))

;; returns an updated substitution and a function that will run all
;; the relevant constraints
(define (update-s-prefix s c s^)
  (define p (prefix-s s s^))
  (define relevant-vars (map car p))
  (define e (add-substitution-prefix-event p))
  (define run-constraints-fn
    (run-relevant-constraints relevant-vars c e))
  (values (ext-s* p s) run-constraints-fn))

;; a function that will safely extend the subsitution with
;; a binding of x to v
(define (update-s-check x v)
  (lambdam@/private (a : s c q t)
    (let ([s (substitution-s s)]
          [c (constraint-store-c c)])
      (let [(x (walk x s))
            (v (walk v s))]
        (cond
         [(or (var? x) (var? v))
          (update-s-internal x v s c q t)]
         [(equal? x v) a]
         [else mzerom])))))

;; a function that will insecurely extend the substitution 
;; with a binding of x to v 
(define (update-s-nocheck x v)
  (lambdam@/private (a : s c q t)
    (let ([s (substitution-s s)]
          [c (constraint-store-c c)])
      (update-s-internal s c q t))))

(define update-s update-s-check)

;; == FIXPOINT =================================================================

;; fixed point algorithm given some variables x* that have changed,
;; and list of constraints c.  will rerun any constraints in c that
;; mention x*
(define (run-constraints c)
  (cond
   [(hash? c)
    (for/fold 
     ([rest identitym])
     ([(key ocs) c])
     (conj 
      (for/fold 
       ([fn identitym])
       ([oc ocs])
       (conj fn (rem/run oc)))
      rest))]
   [(list? c)
    (for/fold 
     ([rest identitym])
     ([oc c])
     (conj rest (rem/run oc)))]
   [else (error 'run-constraints "don't know how to run ~s" c)]))

(define (run-relevant-constraints x* c [e #f])
  (for/fold 
   ([rest identitym])
   ([(key ocs) c])
   (conj 
    (for/fold 
     ([fn identitym])
     ([oc ocs]
      #:when (any-relevant/var? (oc-rands oc) x*))
     (conj fn (rem/run oc e)))
    rest)))

;; removes a constraint from the constraint store and then 
;; reruns it as if it was just being introduced (will add itself
;; back to the constraint store if it still is waiting on info)
(define (rem/run oc e)
  (lambdam@/private (a : s c q t)
    (let ([ocs (constraint-store-c c)])
      (cond
       [(memq-c oc ocs)
        (bindm 
          (let ([new-c (constraint-store (remq-c oc ocs))])
            (make-a s new-c q t))
          (oc-proc oc)
          e)]
       [else a]))))

(define-syntax case/lazy
  (syntax-rules ()
    [(_ gen [() no-answer-clause] [(x g) an-answer-clause])
     (let ([g gen])
       (call-with-values (lambda () (g))
         (case-lambda
          [() no-answer-clause]
          [(x) an-answer-clause])))]))

;; given a number n and a stream, takes n answers from f
(define (take n stream)
  (cond
   [(and n (zero? n)) '()]
   [else
    (case/lazy stream
     [() '()]
     [(a _) (cons a (take (and n (- n 1)) stream))])]))

(define (take/lazy f)
  (case-inf (f)
   [() (yield)]
   [(f) (take/lazy f)]
   [(a) (yield a)]
   [(a f) (begin (yield a) (take/lazy f))]))

;; == ENFORCE CONSTRAINTS ======================================================

;; a list of functions to be run during enforce
(define enforce-fns (make-parameter '()))
(define extend-enforce-fns (extend-parameter enforce-fns))

;; runs all the enforce-constraint functions in enforce-fns
;; and all the fixpoint-enforce-fns in fixpoint-enforce-fns.. to a fixpoint
(define (enforce x)
  (for/fold
   ([f fixpoint-enforce])
   ([fn (map cdr (enforce-fns))])
   (conj f (fn x))))

(define-for-syntax search-strategy (make-parameter 'hybrid))

;; runs the given search strategy on the queue of lazy goals
(define fixpoint-enforce
  (lambdam@/private (a : s c q t)
    (cond
     [(empty-q? q) a]
     [else 
      ((ext-q q fixpoint-enforce) 
       (make-a s c empty-q t))])))

;; useful for printing out information during debugging, not exported atm
;; convenience macro for defining lazy goals
(define-syntax (define-lazy-goal stx)
  (syntax-parse stx
    [(define-lazy-goal (name args ...) body)
     (define (bad-search-strat-error st)
       (error 'define-lazy-goal "unknown search strategy ~s" st))
     (let ([st (search-strategy)])
       (with-syntax 
         ([update-q
           (case st
             [(dfs) #'update-q-dfs]
             [(bfs) #'update-q-bfs]
             [(hybrid) #'update-q-hybrid]
             [else (bad-search-strat-error st)])])
         #`(define (name args ...) (update-q body))))]
    [(define-lazy-goal name (lambda (args ...) body))
     #'(define-lazy-goal (name args ...) body)]))

;; == REIFICATION ==============================================================

;; a list of functions to be run during reification
(define reify-fns        (make-parameter '()))
(define extend-reify-fns (extend-parameter reify-fns))

;; defines whether the constraint store should be printed out
;; with a : inbetween the answer and the constraints on the answer
(define reify-with-colon (make-parameter #t))

;; reifies the constraint store with respect to x
(define (reify x)
  (lambdam@/private (a : s c q t)
    (let ([s (substitution-s s)]
          [c (constraint-store-c c)])
      (define v (walk* x s))
      (define r (reify-s v empty-s))
      (define v^ (reify-term v r))
      (define answer
        (cond
         [(null? r) v^]
         [else (reify-constraints v^ r c)]))
      (choiceg answer empty-f))))

;; reifies a cvar
(define (reify-cvar cvar r) (walk cvar r))

;; reifies the substitution, returning the reified substitution
(define (reify-s v s)
  (let ((v (walk v s)))
    (cond
     [(var? v) 
      `((,v . ,(reify-n v (size-s s))) . ,s)]
     [(mk-struct? v) 
      (let ([k (lambda (a d) (reify-s d (reify-s a s)))])
        (recur v k))]
     [else s])))

;; creates a reified symbol
(define (reify-n cvar n)
  (string->symbol (format "~a.~a" (cvar->str cvar) (number->string n))))

;; reifies the constraint store by running all the reification fns
(define (reify-constraints v r ocs)
  (cond
    ((null? ocs) v)
    (else
     (let ((ocs^ (run-reify-fns v r ocs)))
       (cond
        [(null? ocs^) v] 
        [(reify-with-colon) `(,v : . ,(sort-store ocs^))]
        [else `(,v . ,(sort-store ocs^))])))))

;; runs all the reification functions
(define (run-reify-fns v r ocs)
  (for/fold ([ocs^ `()])
            ([fn (map cdr (reify-fns))])
    (append (fn v r ocs) ocs^)))

;; defines a "default" reify function
(define ((default-reify sym cs fn) v r ocs)
  (let ((ocs (filter-memq/rator cs ocs)))
    (let ((rands (filter-not any/var? (walk* (fn (map oc-rands ocs) r) r))))
      (cond
       ((null? rands) `())
       (else `((,sym . ,(sort rands lex<=))))))))

(define ((default-reify-attr sym type fn) v r ocs)
  (let ([ocs (filter (lambda (oc) (eq? (attr-oc-type oc) type))
                     (filter/rator attr-tag ocs))])
    (let ([rands (filter-not any/var? (walk* (fn (map (compose car oc-rands) ocs) r) r))])
      (cond
       [(null? rands) `()]
       [else `((,sym . ,(sort rands lex<=)))]))))

;; sorts the constraint store by lex<=
(define (sort-store ocs) (sort ocs lex<= #:key car))

;; sorts a list by lex<=
(define (sort-by-lex<= l) (sort l lex<=))

;; for pretty reification
(define lex<=
  (lambda (x y)
    (cond
      ((vector? x) #t)
      ((vector? y) #f)
      ((port? x) #t)
      ((port? y) #f)
      ((procedure? x) #t)
      ((procedure? y) #f)
      ((boolean? x)
       (cond
         ((boolean? y) (or (not x) (eq? x y)))
         (else #t)))
      ((boolean? y) #f)
      ((null? x) #t)
      ((null? y) #f)
      ((char? x)
       (cond
         ((char? y) (char<=? x y))
         (else #t)))
      ((char? y) #f)
      ((number? x)
       (cond
         ((number? y) (<= x y))
         (else #t)))
      ((number? y) #f)
      ((string? x)
       (cond
         ((string? y) (string<=? x y))
         (else #t)))
      ((string? y) #f)
      ((symbol? x)
       (cond
         ((symbol? y)
          (string<=? (symbol->string x)
                     (symbol->string y)))
         (else #t)))
      ((symbol? y) #f)
      ((pair? x)
       (cond
         ((pair? y)
          (cond          
            ((equal? (car x) (car y))
             (lex<= (cdr x) (cdr y)))
            (else (lex<= (car x) (car y)))))))
      ((pair? y) #f)
      (else #t))))

;; == INTEGRATION ==============================================================

(define-syntax run/lazy
  (syntax-rules ()
    ((_ (x) g ...) 
     (let ([a-inf ((fresh (x) g ... (enforce x) (reify x)) empty-a)])
       (generator () (take/lazy a-inf))))))

;; convenience macro to integrate Scheme and cKanren, 
;; returns n answers to the goals g0 g1 ... where x is fresh
(define-syntax run
  (syntax-rules ()
    ((_ n (x) g0 g1 ...)
     (let ([stream (run/lazy (x) g0 g1 ...)])
       (take n stream)))))

;; RUNS ALL THE THINGS
(define-syntax run*
  (syntax-rules ()
    ((_ (x) g ...) (run #f (x) g ...))))

(struct running (x a-inf)
  #:methods gen:custom-write 
  [(define (write-proc ra port mode) 
     ((parse-mode mode) "#<running/interactive>" port))])

(struct enforced running ()
  #:methods gen:custom-write 
  [(define (write-proc ra port mode) 
     ((parse-mode mode) "#<running/interactive>" port))])

(define-syntax (start/interactive stx)
  (syntax-parse stx
    [(_ (~seq #:var x) g ...)
     #'(running x (bindm empty-a (conj succeed g ...)))]))

(define-syntax-rule 
  (resume/interactive state g ...)
  (let ([st state])
    (let ([x (running-x st)]
          [a-inf (running-a-inf st)])
      (running x (bindm a-inf (conj succeed g ...))))))

(define-syntax-rule 
  (enforce/interactive state)
  (let ([st state])
    (let ([x (running-x st)]
          [a-inf (running-a-inf st)])
      (enforced x (bindm a-inf (enforce x))))))

(define-syntax-rule
  (reify/interactive state)
  (let ([st state])
    (unless (enforced? st)
      (error 'reify/interactive "trying to reify an unenforced state ~s" st))
    (let ([x (running-x st)]
          [a-inf (running-a-inf st)])
      (bindm a-inf (reify x)))))

(define-syntax-rule 
  (exit/interactive n state)
  (let ([stream
         (generator 
          ()
          (take/lazy
           (let ([st state])
             (reify/interactive
              (cond
               [(enforced? st) state]
               [else (enforce/interactive state)])))))])
    (take n stream)))

(define-syntax-rule
  (exit*/interactive state)
  (exit/interactive #f state))

;; == HELPERS ==================================================================

;; This is a tracing macro, akin to trace-define in Chez Scheme.  Upon
;; entry to the goal, all arguments to the function will be projected
;; in the current substitution and printed out.
(define-syntax trace-define
  (syntax-rules ()
    ((_ (name a* ...) body)
     (trace-define-mk name (lambda (a* ...) body)))
    ((_ name (lambda (a* ...) body))
     (define name
       (lambda (a* ...)
         (conj
           (project (a* ...)
             (begin
               (display (list 'name a* ...))
               (newline)
               succeed))
           body))))))

;; Should be able to think of importing constraint files as using
;; constraints, not as requiring files.  Abstractiiooonnnnn.
(define-syntax-rule (use-constraints file ...) 
  (require file ...))

;; (define gensym
;;   (let ([counter 0])
;;     (lambda ([x 'g])
;;       (if (number? x)
;;           (set! counter x)
;;           (begin0 (string->unreadable-symbol
;;                    (format "~a~a" x counter))
;;                   (set! counter (add1 counter)))))))

;; =============================================================================


(struct event ())
(struct add-constraint-event event (oc))
(struct add-association-event event (u v))
(struct add-substitution-prefix-event (p))

(begin-for-syntax
 (define-syntax-class package-splicer
   (pattern (a : s) #:attr bds (list #'a #'s (generate-temporary #'?c)))
   (pattern (a : s c) #:attr bds (list #'a #'s #'c))
   (pattern a #:attr bds (list #'a (generate-temporary #'?s) (generate-temporary #'?c)))))

(define-syntax (constraint stx)
  (syntax-parse stx
    [(constraint 
      (~or (~optional (~seq #:package ps:package-splicer))
           (~optional (~seq #:event e:id)))
      ...
      body ...)
     (with-syntax 
       ([(a s c) (attribute ps.bds)]
        [e (or (attribute e) (generate-temporary #'?e))])
       #'(lambdam@/private (a e)
           (let ([s (substitution-s (a-s a))]
                 [c (constraint-store-c (a-c a))])
             (bindm a (begin body ...) e))))]))

#;
(define-syntax (update-args stx)
  (syntax-parse stx
    [(update-args e (args ...) ((x fn) ...))
     ]))

(define (walk-event u s e)
  (cond
   [(and (add-association-event? e)
         (eq? (add-association-event-u e) u))
    (add-association-event-v e)]
   [(and (add-substitution-prefix-event? e)
         (assq u (add-substitution-prefix-event-p e)))
    => cdr]
   [else u]))

